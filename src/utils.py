import csv
import gzip
import time

from libs import *
from config import *

class Data(dict):
	def __getattr__(self, name):
		try:
			return self[name]
		except KeyError:
			raise AttributeError(name)

	def __setattr__(self, name, val):
		self[name] = val

def abundant_motifs(rows):
	res = [rows[0]]
	rows = rows[1:]
	indexes = []
	mlen = 0
	for idx, row in enumerate(rows):
		if len(row[0]) > mlen:
			indexes.append(idx)
			mlen = len(row[0])
	
	indexes.append(len(rows))
	
	for i in range(len(indexes)-1):
		tmp = sorted(rows[indexes[i]:indexes[i+1]], key=lambda x: (x[0], -x[1]))
		res.extend(tmp[:5])
	
	return res

def time_format(dt):
	if dt is None:
		return ''
	else:
		return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(dt))

def used_format(dt):
	if dt == 0:
		return "0s"
	
	hours = int(dt/3600)
	divisor_for_minutes = dt % 3600
	minutes = int(divisor_for_minutes/60)
	divisor_for_seconds = divisor_for_minutes % 60
	seconds = int(divisor_for_seconds)

	res = []
	if hours:
		res.append("%sh" % hours)

	if minutes:
		res.append("%smin" % minutes)

	if seconds:
		res.append("%ss" % seconds)

	return " ".join(res)



env = Environment(loader=FileSystemLoader(TEMPLATE_DIR))
env.filters['time_format'] = time_format
env.filters['used_format'] = used_format
env.filters['abundant_motifs'] = abundant_motifs
def template_render(template_name, **kwargs):
	template = env.get_template(template_name)
	return template.render(**kwargs)

def format_to_gff(feature, row):
	cols = [row.sequence, 'Krait', feature, row.start, row.end, '.', '+', '.', []]
	cols[-1].append("ID={}{}".format(feature, row.id))
	cols[-1].append("Motif={}".format(row.motif))
	for k in row.getKeys():
		if k not in ['id', 'sequence', 'start', 'end', 'motif']:
			cols[-1].append("{}={}".format(k.capitalize(), row.value(k)))
	cols[-1] = ";".join(cols[-1])
	return cols

def write_to_gtf(gtf_file, feature, cursor):
	with open(gtf_file, 'w') as gtf:
		gtf.write("#!gtf-version 2\n")
		gtf.write("#!generated by Krait %s\n" % VERSION)
		for row in cursor:
			cols = [row.sequence, 'Krait', feature, row.start, row.end, '.', '+', '.', []]
			cols[-1].append('gene_id "%s%s"' % (feature, row.id))
			cols[-1].append('transcript_id "%s%s"' % (feature, row.id))
			cols[-1].append('motif "%s"' % row.motif)
			for k in row.getKeys():
				if k not in ['id', 'sequence', 'start', 'end', 'motif']:
					cols[-1].append('%s "%s"' % (k, row.value(k)))
			cols[-1] = "; ".join(cols[-1])
			gtf.write("\t".join(map(str, cols))+'\n')

def format_sql_where(conditions):
	symbols = ['>=', '<=', '>', '<', '=', ' in ']
	conditions = conditions.split()
	for idx, cond in enumerate(conditions):
		if cond == 'in':
			items = conditions[idx+1].strip('()').split(',')
			if not items[0].isdigit():
				conditions[idx+1] = "(%s)" % ",".join(map(lambda x: "'%s'" % x, items))
			continue

		if cond in symbols:
			if not conditions[idx+1].isdigit():
				conditions[idx+1] = "'%s'" % conditions[idx+1]
			continue

		for symbol in symbols:
			if symbol in cond:
				res = cond.split(symbol)
				if not res[1].isdigit():
					res[1] = "'%s'" % res[1]
					conditions[idx] = "%s%s%s" % (res[0], symbol, res[1])

	return " ".join(conditions)

def format_fasta_sequence(sequence, length):
	seqs = []
	for idx, base in enumerate(sequence):
		seqs.append(base)
		if (idx+1) % length == 0:
			seqs.append('\n')
	seqs.append('\n')
	return "".join(seqs)

'''
def gff_gtf_parser(annot_file, _format='GFF'):
	"""
	parse GFF, GTF, comparessed gz annotation file
	"""
	if annot_file.endswith('.gz'):
		fh = gzip.open(annot_file, 'rt')
	else:
		fh = open(annot_file)

	for line in fh:
		if line[0] == '#': continue
		cols = line.strip().split('\t')
		record = Data(
			seqid = cols[0],
			feature = cols[2].upper(),
			start = int(cols[3]),
			end = int(cols[4]),
			attrs = Data()
		)
		
		for item in cols[-1].split(';'):
			if not item:
				continue
			
			if _format == 'GFF':
				name, value = item.split('=')
			else:
				name, value = item.strip().strip('"').split('"')
			
			record.attrs[name.strip()] = value
		
		yield record

	fh.close()

def get_gtf_coordinate(gtf_file):
	father = None
	exons = []
	for r in gff_gtf_parser(gtf_file, 'GTF'):
		try:
			gene_name = r.attrs.gene_name
		except AttributeError:
			gene_name = r.attrs.gene_id

		meta = Data(
			feature = r.feature,
			gene_id = r.attrs.gene_id,
			gene_name = gene_name,
		)

		if r.feature == 'CDS':
			yield (r.seqid, r.start, r.end, meta)
		
		elif r.feature == 'FIVE_PRIME_UTR':
			meta.feature = '5UTR'
			yield (r.seqid, r.start, r.end, meta)
		
		elif r.feature == 'THREE_PRIME_UTR':
			meta.feature = '3UTR'
			yield (r.seqid, r.start, r.end, meta)
		
		elif r.feature == 'UTR':
			yield (r.seqid, r.start, r.end, meta)
		
		elif r.feature == 'EXON':
			meta.feature = 'exon'
			mother = r.attrs.transcript_id

			if father == mother:
				exons.append((r.seqid, r.start, r.end, meta))
			else:
				if exons:
					exons = sorted(exons, key=lambda x: x[1])
					intron_chrom = exons[0][0]
					intron_meta = exons[0][3]
					intron_meta.feature = 'intron'

					for idx, exon in enumerate(exons):
						yield exon

						if idx < len(exons)-1:
							start = exon[2] + 1
							end = exons[idx+1][1] - 1
							yield (intron_chrom, start, end, intron_meta)
				
				exons = [(r.seqid, r.start, r.end, meta)]
				father = mother

	if exons:
		exons = sorted(exons, key=lambda x: x[1])
		intron_chrom = exons[0][0]
		intron_meta = exons[0][3]
		intron_meta.feature = 'intron'
		for idx, exon in enumerate(exons):
			yield exon

			if idx < len(exons)-1:
				start = exon[2] + 1
				end = exons[idx+1][1] - 1
				yield (intron_chrom, start, end, intron_meta)

def get_gff_coordinate(gff_file):
	father = None
	exons = []

	parents = {}

	for r in gff_gtf_parser(gff_file, 'GFF'):
		if r.feature == 'REGION':
			continue

		elif r.feature == 'GENE':
			if 'ID' in r.attrs:
				parents[r.attrs.ID] = r.attrs.ID
			elif 'GENE' in r.attrs:
				parents[r.attrs.GENE] = r.attrs.GENE
				parents['gene-{}'.format(r.attrs.GENE)] = r.attrs.GENE
			elif 'NAME' in r.attrs:
				parents[r.attrs.NAME] = r.attrs.NAME

		elif r.feature == 'CDS':
			meta = Data(
				feature = r.feature,
				gene_id = parents[r.attrs.Parent].attrs.ID,
				gene_name = parents[r.attrs.Parent].attrs.Name,
			)
			yield (r.seqid, r.start, r.end, meta)
		
		elif r.feature == 'FIVE_PRIME_UTR':
			meta = Data(
				feature = '5UTR',
				gene_id = parents[r.attrs.Parent].attrs.ID,
				gene_name = parents[r.attrs.Parent].attrs.Name,
			)
			yield (r.seqid, r.start, r.end, meta)

		elif r.feature == 'THREE_PRIME_UTR':
			meta = Data(
				feature = '3UTR',
				gene_id = parents[r.attrs.Parent].attrs.ID,
				gene_name = parents[r.attrs.Parent].attrs.Name,
			)
			yield (r.seqid, r.start, r.end, meta)
		
		elif r.feature == 'UTR':
			meta = Data(
				feature = 'UTR',
				gene_id = parents[r.attrs.Parent].attrs.ID,
				gene_name = parents[r.attrs.Parent].attrs.Name,
			)
			yield (r.seqid, r.start, r.end, meta)
		
		elif r.feature == 'EXON':
			try:
				mother = r.attrs.Parent
			except AttributeError:
				continue

			meta = Data(
				feature = 'exon',
				gene_id = parents[r.attrs.Parent].attrs.ID,
				gene_name = parents[r.attrs.Parent].attrs.Name,
			)

			if father == mother:
				exons.append((r.seqid, r.start, r.end, meta))
			else:
				if exons:
					exons = sorted(exons, key=lambda x: x[2])
					intron_chrom = exons[0][0]
					intron_meta = exons[0][3]
					intron_meta.feature = 'intron'

					for idx, exon in enumerate(exons):
						yield exon

						if idx < len(exons)-1:
							start = exon[2] + 1
							end = exons[idx+1][1] - 1
							yield (intron_chrom, start, end, intron_meta)
				
				exons = [(r.seqid, r.start, r.end, meta)]
				father = mother
		else:
			if 'ID' in r.attrs:
				try:
					parents[r.attrs.ID] = parents[r.attrs.Parent]
				except:
					parents[r.attrs.ID] = r.attrs.ID

	exons = sorted(exons, key=lambda x: x[2])
	intron_chrom = exons[0][0]
	intron_meta = exons[0][3]
	intron_meta.feature = 'intron'
	
	for idx, exon in enumerate(exons):
		yield exon

		if idx < len(exons)-1:
			start = exon[2] + 1
			end = exons[idx+1][1] - 1
			yield (intron_chrom, start, end, intron_meta)
'''

def get_ssr_sequence(seq_file, seq_name, start, stop, flank):
	'''
	Get the SSR sequence and flanking sequences
	@para seq_file, the file path of the fasta sequence
	@para seq_name, the name of the fasta sequence
	@para start, the start position of SSR
	@para stop, the stop position of SSR
	@para flank, the length of the flanking sequence
	@return ssr sequence with flanking sequences
	'''
	fastas = fasta.Fasta(seq_file, sequence_always_upper=True)
	
	#get ssr sequence
	ssr = fastas[seq_name][start-1:stop].seq
	
	#get left flanking sequence
	left_flank_start = start - flank - 1
	if left_flank_start < 0:
		left_flank_start = 0
	left_flank = fastas[seq_name][left_flank_start:start]
	
	seq_len = len(fastas[seq_name])
	
	#get right flanking sequence
	right_flank_stop = stop + flank
	if right_flank_stop > seq_len:
		right_flank_stop = seq_len
	right_flank = fastas[seq_name][stop:right_flank_stop]

	highlighter = SequenceHighlighter()
	meta = '%s:%s-%s %s' % (seq_name, left_flank_start+1, start, len(left_flank))
	highlighter.format_flank(left_flank, meta)
	highlighter.format_ssr(ssr)
	highlighter.format_flank(right_flank)
	return highlighter.render()

def human_size(size):
	if size < 1000:
		return '%s B' % round(size, 2)

	size = size/1024
	if size < 1000:
		return '%s KB' % round(size, 2)

	size = size/1024
	return '%s MB' % round(size, 2)

